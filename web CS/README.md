### 1. 브라우저의 동작 원리

1. **요약**

   1. HTML 마크업을 처리하고 DOM 트리를 빌드한다. (**"무엇을"** 그릴지 결정한다.)
   2. CSS 마크업을 처리하고 CSSOM 트리를 빌드한다. (**"어떻게"** 그릴지 결정한다.)
   3. DOM 및 CSSOM 을 결합하여 렌더트리를 형성한다. (**"화면에 그려질 것만"** 결정)
   4. 렌더트리에서 레이아웃을 실행하여 각 노드의 기하학적 형태를 계산한다. (**"Box-Model"** 을 생성해 **정확한 위치**에 표시.)
   5. 개별 노드를 화면에 페인트한다.(or 래스터화)

   

   #### 브라우저의 기본 구조

   - UI - 요청한 페이지를 보여주는 창 외에 사용자가 컨트롤 할 수 있는 모든 부분
   - 브라우저 엔진 - UI와 렌더링 엔진 사이의 동작을 제어 (사용자가 UI를 클릭하면, 명령을 렌더링 엔진에게 전달해주는 역할!)
   - **렌더링 엔진** - 요청한 URI를 브라우저 엔진에게 받아서 server에게 요청한다(**통신**). server로부터 URI에 해당하는 데이터(HTML, CSS, JS)를 받아서 **파싱** 후 화면에 표시(**렌더링**). (ex. chrome webkit)
   - 통신 - 렌더링 엔진으로부터 HTTP 요청을 받아서 네트워크 처리 후 응답을 전달. (OS 단에서 실행)
   - 자바스크립트 해석기 - JS를 파싱, 실행시킴. (ex. chrome V8)
   - UI 백엔드 - 렌더 트리를 브라우저에 그리는 역할.
   - 자료 저장소 - 쿠키 등의 자료를 컴퓨터 하드디스크에 저장. (HTML5부터 웹DB에 저장 가능)

   (그림)

   #### 브라우저 렌더링 과정 (브라우저 구조 관점)

   - 1) 사용자가 주소표시줄(UI)에 URI를 입력하여 브라우저 엔진에게 전달.
   - 2-1) 브라우저 엔진은 자료 저장소에서 URI에 해당하는 자료를 찾고, 해당 자료가 쿠키로 저장되어 있다면, 그 자료를 렌더링 엔진에게 전달. (통신할 필요 X)
   - 2-2) 쿠키에 저장되어 있지 않다면, 렌더링 엔진은 URI 데이터를 통신.
   - 3) 통신 응답을 받으면
     - 렌더링 엔진이 HTML, CSS를 파싱
     - JS 해석기가 JS를 파싱
   - 4) JS해석기가 파싱 결과를 렌더링 엔진에게 전달해 HTML의 파싱 결과인 DOM트리 조작.

   - 5) 조작이 완료된 DOM node(DOM트리 구성요소)는 render object(렌더트리 구성요소)로 변함. 
   - 6) UI 백엔드에서 렌더트리의 각 노드를 가로지르며 형상을 만들어 냄.

   

   #### 렌더링 엔진 동작 과정 (렌더링 엔진 관점)

   : 렌더링 엔진은 URI를 통해 요청을 받아, 해당하는 데이터를 렌더링. chrome과 IOS는 webkit이라는 렌더링 엔진을 사용.

   - 1) DOM트리 구축을 위해, HTML/CSS/JS 파싱 : HTML 문서를 파싱한 후, 컨텐트 트리 내부에서 tag를 DOM node로 변환. CSS 파일과 함께 모든 스타일 요소를 파싱. 스타일 요소와 HTML 표시 규칙, JS의 파싱 결과물은 렌더트리를 생성한다.
   - 2) 렌더트리 구축 : HTML과 CSS를 파싱해서 만들어진 렌더트리는 색상 또는 면적 등 시각적 속성을 갖는 사각형을 포함한다. 정해진 순서대로 렌더링.
   - 3) 렌더트리 배치 : 렌더 트리 생성이 끝나면, 배치가 시작된다. 각 node가 정확한 위치에 표시되기 위해 이동.
   - 4) 렌더트리 그리기 : 각 node 배치를 완료하면, UI 백엔드에서 각 node를 가로지르며 paint 작업을 한다. 

   *1번과 2,3,4번은 병렬적으로 진행!!

   : 즉, 통신 레이어에서 데이터를 계속 받아오면서 -> 받아온 HTML/CSS/JS를 파싱(DOM트리의 자식 요소인 DOM node로 변환)하면서(1번)

     렌더트리에 node를 그린다(렌더트리의 자식요소인 render object로 변환) (2,3,4번)

   =>> 데이터를 받아오는 도중에도 계속 화면이 그려지면서 사용자 경험↑

   

   +) 

   - HTML을 파싱해 DOM트리를 구축하는 이유? -> HTML을 DOM으로 바꿔야 JS를 통해 이를 조작, 동적으로 표현할 수 있기 때문.
   - CSS를 파싱한 결과는 CSSOM(스타일 규칙)이다. (DOM node에 대한 스타일 정보를 가지고 있음)
   - DOM트리를 생성하는 동시에, 이미 생성된 DOM트리와 스타일 규칙을 Attachment한다. (DOM트리를 구성하는 하나의 DOM node는 attach라는 메서드를 가짐. attach 덕분에 DOM node가 바로바로 render object로 변환되는 것!)
   - 모든 DOM node가 전부 render object로 생성되는 것은 아니다. (ex. header, display:none)
   - `<html>`과`<body>`DOM node는 render tree root로서 render view라고 부름.
   - 나머지 DOM node들은 render object로 생성되어 이 render tree root에 추가된다.
   - 구축한 렌더트리를 배치할 때, 최상위 render object에서 시작. 화면 왼쪽 위부터 이 render object에 해당하는 DOM node를 그려나간다.
   - 렌더트리 탐색 후, 해당하는 render object의 paint 메서드를 호출해서 화면에 렌더트리를 그림.



### 2. DOM (Document Object Model)

: HTML, XML 문서에 대한 인터페이스. 프로그래밍 언어가 페이지의 콘텐츠/구조/스타일을 읽고 조작할 수 있도록 API를 제공한다. (DOM에 접근, 조작)

- 뷰 포트에 무엇을 렌더링할지 결정하기 위해 사용됨.
- 페이지의 콘텐츠/구조/스타일이 JS프로그램에 의해 수정되기 위해 사용됨.

HTML 문서의 객체 기반 표현 방식으로, 단순 텍스트로 구성된 HTML 문서의 내용과 구조가 객체 모델로 변환된다. (구조화된 노드, property, method를 갖고 있는 objects로 문서를 표현)

DOM의 개체 구조는 **노드 트리**로 표현된다. 루트 요소인 <html>은 부모줄기, 루트 요소에 내포된 태그들은 자식 나무가지, 요소 안의 컨텐츠는 잎.

- 항상 유효한 HTML 형식이다.
- JS에 의해 수정될 수 있는 동적 모델이어야 한다.
- 가상 요소를 포함하지 않는다.
- 보이지 않는 요소까지 포함한다. (`display: none`)



-예시

```html
<html>
    <head>
        <script>
          window.onload = function() {
              let title = document.createElement("h1");
              let title_text = document.createTextNode("Welcome!");
              title.appendChild(title_text);
              document.body.appendChild(title);
          }
        </script>
    </head>
    <body>
    </body>
</html>
```



참고 문서

https://wit.nts-corp.com/2019/02/14/5522



### 3. CORS (Cross-Origin Resource Sharing)

: 타 도메인 간에 자원을 공유할 수 있게 해주는 것.

이전에는 보안 상의 문제로, Origin 웹서버(동일 도메인/프로토콜/포트)에게만 Ajax 요청을 보낼 수 있지만(same origin policy), HTML5에서 다른 도메인 간 통신이 가능한 CORS라는 스펙이 추가됨.

추가 HTTP 헤더를 사용하여, 어떤 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제. (리소스가 자신의 출처 -도메인/프로토콜/포트 와 다를 때 교차 출처 HTTP 요청을 실행)

- 적용 방법

  : 요청하는 URL의 출처가 다른 경우, XMLHttpRequest 객체가 preflight, actual 요청을 자동으로 처리. 

  - 프론트) request 헤더에 CORS 관련 OPTION 메소드를 넣어줌
  - 서버) response 헤더에 해당하는 요청을 허용한다는 내용을 넣어줌

- Preflight Request

  : 실제 요청을 보내기 전, 안전한지 판단하기 위해 preflight 요청을 먼저 보냄.

  인증 헤더를 전송하여, 서버의 허용 여부를 미리 체크하는 테스트 요청.

  트래픽 증가 문제는 서버의 헤더 설정으로 캐쉬가 가능.



### 4. 크로스 브라우징

: 서로 다른 OS나 플랫폼에 대응하는 것 (어떤 환경에서도 이상없이 작동되도록). 

브라우저의 렌더링 엔진이 다른 경우, 인터넷이 이상없이 구현되도록 하는 기술. 

즉, 어느 한쪽에 최적화되어 치우치지 않도록 공통요소를 사용해 웹페이지를 제작하는 방법.

- 웹표준 검사하기 (Can i use? / CSS-Validator)
- feature detection
- reset.css 사용하기 (default 값 초기화)
- prefix 적기



### 5. SSR(Server Side Rendering) vs CSR(Client Side Rendering)

- SPA (Single Page web Application)

  : 최초 한번 페이지 전체(정적 리소스)를 로딩한 이후부터는 데이터만 변경해 사용할 수 있는 웹 애플리케이션. 전체적인 트래픽을 감소할 수 있고, 새로고침이 발생하지 않아 사용자 경험 향상.

- SSR : 요청할 때마다 새로고침이 발생해, 서버로부터 리소스를 전달받아 해석/렌더링. 데이터가 많을수록 성능문제 발생.

  - 장점) 초기로딩 성능 개선. SEO 최적화.
  - 단점) 매번 서버에 request 요청을 통해 해결. DOM 조작 시, 요청/탐색 비용 발생 (성능 악화)

- CSR : 서버는 단지 JSON 파일만 보내주는 역할을 하고, html을 그리는 역할은 클라이언트 측에서 자바스크립트가 수행.

  - 장점) 초기 구동 이후, 빠른 인터랙션.
  - 단점) 초기 구동 속도가 느림. 검색엔진 최적화 문제(HTML 에서만 콘텐츠를 수집). 보안문제(사용자 정보를 쿠키 외에 저장할 공간이 마땅치 않음)



### 6. 쿠키/세션/캐시

- **쿠키** : 사이트에 방문/이동할 때, 브라우저에 저장되는 내용. (클라이언트 측에 저장되는 정보) 
  - 보안 위험 존재
  - 사용자의 편의를 위하되, 지워지거나 조작되거나 가로채이더라도 큰 일은 없을 수준의 정보를 브라우저에 저장하는데 사용. 
  - 형식: text / 용량: 20개 per 도메인, 4KB per 쿠키
  - 예시
    - 로그인 창의 아이디 자동완성.
    - 공지 메시지 하루 안보기
    - 로그인 안한 상태로 장바구니에 담기
- **세션** : 사용자나 다른 누군가에게 노출되어서는 안되는, 서비스 제공자가 직접 관리해야 할 정보들을 서버에 저장해 다룸. 
  - 형식: object / 용량: 제한없음
  - 과정
    - 서버에서 사용자를 구분하기 위해, 기한이 짧은 임시 key 하나를 브라우저에 보내 쿠키로 저장. 
    - 사용자의 중요한 정보들은 이 서버의 메모리나 데이터 베이스에 저장됨. 
    - 브라우저가 이 사이트의 페이지들에 접속할 때마다, http요청에 이 key가 담긴 쿠키를 실어서 전송.
    - 서버는 그 key를 보고, 사용자를 식별/인식해서 해당 정보를 가공, 응답으로 보내줌.
- **캐시** : 가져오는데 비용이 드는 데이터를 한번 가져온 뒤에는 임시로 저장해두는 것. 
  - 이미지 데이터를 받아올 때, 데이터 사용량 및 시간이 발생. 
  - 사용자가 여러 번 방문할 법한 사이트에서는 한 번 받아온 데이터를 사용자의 컴퓨터 혹은 중간 역할을 하는 서버에 저장해둠.

*웹 개발자는 어떤 정보를 쿠키에 담을지, 세션에 담을지 적절한 판단을 내릴 수 있어야 한다.