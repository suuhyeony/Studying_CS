## Network

### 0. 용어정리

**Networking** - 서로 연결해 대화할 수 있게 하는 것. (장비들을 서로 대화 가능하도록 묶어주는 것)

**Internet** - 여러 개의 네트워크를 묶은 것. 하나의 프로토콜을 사용한다.(인터넷 통신 규칙 -> TCP/IP 사용) 웹 브라우저로 인터넷을 탐험.

**IntraNet** - 내부의 네트워크 (사내업무도 웹 브라우저로 하는 것). 외부허용 불가.

**ExtraNet** - 기업의 인트라넷을 협력회사나 고객에게 사용할 수 있도록 하는 것.

<br>

**LAN(Local Area Network)** - 어느 한정된 공간에서 네트워크를 구성하는 것. (<-> WAN)

**Ethernet** - 네트워킹의 한 방식. CSMA/CD(눈치껏 대충하는 통신. 순서X, 충돌방생, 더 빠름)라는 프로토콜로 통신.

**TokenRing** - 네트워킹의 한 방식. 토큰을 가진 순서에 따라 통신. 속도 떨어짐.

<br>

**IP 주소** - 네트워크 환경에서 디바이스간 소통하기 위한 유일한 주소. (동네를 확인) Logical 주소라고도 한다.

**MAC address** - 각 컴퓨터를 네트워크 상에서 구별할 수 있도록 하는 주소. (모든 LAN의 디바이스들은 유일한 MAC 주소를 가짐. 이걸 알아야 통신이 가능하다.) Physical 주소라고도 한다.

**ARP** - IP주소를 MAC으로 바꾸는 절차.

<br>

**Unicast** - 특정 목적지의 주소 하나만을 가지고 통신하는 방식. MAC주소를 자신의 주소와 비교해 아니면 프레임 버림. (다른 PC들의 CPU성능을 저하X)

**Broadcast** - 로컬 LAN(라우터에 의해 구분된 공간, broadcast domain)에 붙어있는 모든 네트워크 장비들에게 보내는 통신. 자신의 주소와 같지 않아도, 패킷을 CPU에 보냄. (CPU성능을 저하시킴)

- ARP / 라우터간 정보교환 / 다른 라우터 찾을 때 사용 (주기적 발생)

**Multicast** - 보내고자 하는 그룹 멤버들에게만 한번에 보낼 때 사용 (해당 기능을 지원해야함)

<br>

 **LAN Card(=네트워크 어댑터 / NIC)** - 유저의 데이터를 케이블에 실어서 허브/스위치/라우터 등으로 전달하거나, 자신에게 온 데이터를 CPU에게 전달.

**HUB** - 포트가 여러 개 달린 장비로, 한 포트로 들어온 데이터를 나머지 포트로 뿌려줌. 같은 HUB에 연결된 모든 PC들은 같은 collision domain에 있다.

**스위치** - 원하는 목적지에 데이터 패킷을 전송하는 장치. 허브와 달리 스위치는 무작정 데이터 패킷을 뿌리는 것이 아니라, IP와 MAC 주소를 기반으로 필요한 장치에게만 데이터 패킷을 전송. 

collision domain을 나누어 주는 장비. (포트 수별로 나뉨) 어떤 PC간 통신하고 있을 때, 동시에 다른 PC들도 통신 가능하도록.

**라우터** - **LAN(Local Area Network:근거리 통신망)을 연결해 주는 장치**로써, 데이터를 전송할 때, 최종 목적지에 가기 위해 거쳐야하는 많은 경로들 중에, 적절한 통신 경로를 결정하기 위해 한 통신망에서 다른 통신망으로 데이터 패킷을 전송하는 장치.

<br>

### 1. HTTP vs HTTPS

#### -HTTP (Hyper-text Transfer Protocol)

: 인터넷상의 커뮤니케이션에 사용되는 형식 중의 하나. (인터넷 규약)

웹상에서 클라이언트와 서버 간에 요청/응답으로 데이터를 주고받는 가장 기초적인 프로토콜.

- **HTTP의 특징**

  - 1. **비연결성**(Connectionless)

    ​       : 클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면, 맺었던 연결을 끊어버리는 성질.

    - 비연결성의 장점 ) 연결을 유지하기 위한 자원을 줄이면 더 많은 연결을 할 수 있다.
    - 비연결성의 단점 ) 서버는 클라이언트를 기억하지 못하므로, 동일 클라이언트의 요청에 대해 매번 새로운 연결을 시도/해제해야 하므로 연결/해제에 대한 오버헤드가 발생.
    - 해결책 : KeepAlive - 지정 시간동안 서버와 클라이언트 사이에 패킷 교환이 없을 경우, 서로의 안부를 묻기위해 패킷을 주기적으로 보내는 것. 이 때, 반응이 없으면 연결을 끊게 된다. (주기적으로 상태를 체크하는 것은 메모리를 많이 잡아먹음)

  - 2. 무상태성(Stateless)

       : 비연결성으로 인해 서버는 클라이언트를 식별할 수 없고, 이전에 주고받았던 데이터/상태를 기억하지 못하는 성질.

       - 상태를 기억하는 방법1) - 쿠키

         : 브라우저 단에서 쿠키를 저장하여 서버가 클라이언트를 식별할 수 있도록 함. 정보가 브라우저에 저장되므로, 보안에 취약.

       - 상태를 기억하는 방법2) - 세션

         : 브라우저가 아닌 서버 단에서 사용자 정보를 저장하는 구조. 쿠키보다는 안전하지만, 사용자가 많을 경우 서버 과부하 발생.

       - 상태를 기억하는 방법3) -토큰을 사용하는 OAuth, JWT

         : 쿠키와 세션의 문제점을 보완하기 위해 토큰 기반 인증방식이 도입되었다. 보호할 데이터를 토큰으로 치환하여, 원본 데이터 대신 토큰을 사용하는 기술. (보안성 높음)

<br>

- **HTTP의 문제점**

  - 1) HTTP는 평문 통신이기 때문에 **도청**이 가능. (TCP/IP는 도청 가능한 네트워크)

    => 통신 자체를 암호화(SSL- Secure Socket Layer)하거나, TLS(Transport Layer Security)라는 다른 프로토콜을 조합해 암호화 가능.

  - 2) **통신 상대를 확인하지 않으므로, 위장**이 가능. (누구든지 요청을 보내고, 응답해야하는 의무가 있음) 서버-클라이언트 간 서로 확인이 불가, 안전한 사용자인지도 모름.

    => SSL로 상대를 확인할 수 있는데, 신뢰할 수 있는 제 3자 기관이 발급한 증명서를 이용하면 된다. (클라이언트는 이 증명서로 본인확인/웹사이트 인증도 가능)

  - 3) **완전성을 증명할 수 없으므로, 변조**가 가능. (=중간자 공격)

    => 해시값 확인 / 파일의 디지털 서명 확인 / HTTPS를 사용해야 확실히 방지가 된다(메시지 다이제스트 방법으로, 데이터로부터 고정길이를 계산, 비교해 확인.)

<br>

#### -HTTPS (Hyper-text Transfer Protocol over SSL)

: **HTTP에 암호화와 인증, 완전성 보호를 더한 형식.**

HTTP 통신을 하는 소켓부분을 SSL/TLS라는 프로토콜로 대체한 것.

원래 HTTS는 TCP와 직접 통신했지만, HTTPS는 SSL과 통신하고, SSL이 TCP와 통신.

- 웹사이트로 보내는 **정보를 제 3자가 보지 못하게** 한다. (HTTP형식. 즉, 텍스트 그대로 보내면 누구든 알아볼 수 있는 형식으로 보내진다.) HTTPS는 뒤죽박죽된 텍스트로 변경해서 실어보낸다.

  - 대칭키) 같은 키로 암호화/복호화

    : 키값을 넣고 암호화해서 보내면 전혀 다른 문자가 되어 보내짐. 받을 때는 해당 키값을 넣고, 알고리즘을 거꾸로 돌리면 풀 수 있다. (동일한 키를 가지고 있어야 함. 키가 노출되면 보안 문제 발생)

  - 비대칭키, 공개키) 서로 다른 한 쌍의 키

    : 두 개의 키는 무조건 한 쌍으로 움직임. (A키로 암호화하면, B키로 복호화. 또는 그 반대) 서버에서 두 키들 중 하나는 비밀로 보관(개인키)하고, 다른 하나를 대중에게 공개(공개키) 

- 접속한 사이트가 **신뢰할 수 있는 사이트인지 판별**해준다.

  - 서버에서 개인키로 암호화해서 웹사이트 정보를 보내면, 우리는 공개키로 복호화해서 볼 수 있다. (불법 사이트라면 공개키로 복호화 불가능!)
  - 브라우저들은 CA(개인키의 인증을 돕는 기업)의 목록들을 내장해서 공개키가 정품인지 알려줌

- **HTTPS의 SSL에서 사용하는 하이브리드 암호 시스템**

  : 비대칭/대칭키 암호화 방식을 혼합한 암호 시스템으로, 대칭키를 비대칭키 암호화 방식으로 공유한 뒤, 다음부터의 통신은 대칭키를 사용해 암호화한다.

<br>

#### -HTTP 구현과정

**1) 신뢰를 위한 탐색과정 (handshake)**

- 클라이언트는 **랜덤 데이터를 생성해 서버에 보냄**
- 이를 받은 서버도 **랜덤 데이터를 생성 + 해당 서버의 인증서**를 실어 보냄 (둘은 악수했다!!)

**2) 인증서가 정품인지 확인** (브라우저에 내장된 CA들의 정보를 통해)

- CA의 인증을 받은 인증서들은 해당 **CA의 개인키로 암호화**되어있음.

- 인증서가 **진짜라면, 브라우저에 저장되어 있는 CA의 공개키로 복호화할 수 있다!**

  - CA 목록에 그 인증서가 없다면, 브라우저 주소창엔 `not secure`이 뜸

- 성공적으로 **복호화된 인증서에는 서버의 공개키가 포함**되어있음


**3) 서버와 데이터 주고 받기** (다량의 데이터를 비대칭으로 하면 부담되기 때문에 **대칭/비대칭 방식으로 데이터를 주고 받음**)

- 클라이언트는 처음 악수할 때 주고받은 **랜덤 데이터 2개를 혼합해 임시 키를 생성**
- 이 임시 키는 **서버의 공개키로 암호화돼서 서버로 보내짐**
- 양쪽에서 일련의 과정을 거쳐 **동일한 대칭키가 만들어짐**

- **비대칭키를 사용하여 대칭키를 공유!** (제 3자가 대칭키를 알 수 없다)
- 이후 **대칭키를 사용해 데이터를 암호화** (대칭키는 서버와 클라이언트 둘만 갖고 있음~)

<br>

### 2. HTTP의 GET vs POST

- HTTP : 웹상에서 클라이언트와 서버 간에 요청/응답으로 데이터를 주고받을 수 있는 프로토콜.

  - HTTP 메소드 ) 서버가 요청을 수행하기 위해 해야할 행동을 표시하는 용도로, HTTP 요청에 포함되어 전송.

- **GET** : 서버로부터 **정보를 조회**하기 위해 설계된 메소드.

  - 필요한 데이터를 Body에 담지 않고, **헤더에 포함**시켜 요청.

    - 쿼리스트링(URL에`?이름1=값1&이름2=값2`)을 통해 전송. => 특정 페이지를 링크/북마크 가능.

  - URL에 데이터가 노출되어 보안에 취약. (ex. 패스워드가 노출되는 경우)

  - **데이터 양에 한계**가 있음.

  - 불필요한 요청을 제한하기 위해 브라우저에서 **요청이 캐시(저장)**될 수 있다. (js, css, image 와 같은 정적 컨텐츠는 데이터양이 크고, 변경될 일이 적어서 재요청을 보낼 필요가 없음) => 속도를 높이고, 즐겨찾기를 편리하게 해줌.

    *정적 컨텐츠 캐시 문제 때문에 컨텐츠를 변경해도 내용이 바뀌지 않을 수 있어, 이 때는 브라우저의 캐시를 지워주어야 한다.

  - Idempotent ) 동일한 요청을 여러 번 전송하더라도 동일한 응답이 돌아와야 함. 데이터/상태를 변경시키지 않아야 함.

    - 웹페이지 열어보기
    - 게시글 읽기

- **POST** : 데이터를 서버로 제출하여 리소스를 **생성/변경**하기 위한 메소드.

  - 데이터를 HTTP 메시지의 **Body에 담아** 전송. (URL에 변수노출X)

    => 요청 헤더의 content-Type에 요청 데이터의 타입을 표시해야 함.

  - Body는 길이의 제한이 없음. (**대용량 데이터 전송 가능**) / 최대 요청을 받는 시간 Time out이 존재해서 클라이언트가 페이지를 요청하고 기다리는 시간이 존재.

  - 민감한 데이터는 반드시 암호화해서 전송해야 함. (Body에 담겨있지만, 여러 툴로 확인 가능하므로)

  - **캐싱할 수 없음**.

  - non-Idempotent ) 서버에게 동일한 요청을 여러 번 전송해도 응답은 항상 다를 수 있음. 서버의 상태/데이터 변경시킴.

    - 게시글 작성
    - cf) 수정- PUT or PATCH / 삭제 - DELETE

*참고 - https://hongsii.github.io/2017/08/02/what-is-the-difference-get-and-post/

<br>

### 3. TCP vs UDP

#### -TCP (Transmission Control Protocol)

: 신뢰성있는 데이터 통신을 가능하게 해주는 전송계층 프로토콜

- connection 연결 (3 way-handshake) - 양방향 통신
- 데이터의 순차 전송을 보장
- Flow control (흐름 제어)
- Congestion control (혼잡 제어)
- Error detection (오류 감지)



*Segment : TCP 프로토콜의 PDU. 데이터를 cut해서 각각의 데이터 앞에 TCP 헤더를 붙임.

<br>

#### TCP의 문제점

- 전송의 신뢰성은 보장하지만, 매번 connection을 연결해 시간손실 발생 (3-way-handshake)
- 패킷을 조금만 손실해도 재전송

<br>

#### -UDP (User Datagram Protocol)

: TCP보다 신뢰성이 떨어지지만, 전송속도가 일반적으로 빠른 프로토콜. 연결 절차를 거치지 않고, 일방적으로 데이터를 보냄.

- 속도가 빠르다.

- 순차 전송X, 흐름제어X, 혼잡제어X
- Connectionless (3-way-handshake X)
- Error detection
- 비교적 데이터의 신뢰성이 중요하지 않을 때 사용 (ex. 영상 스트리밍)



*User Datagram : UDP의 프로토콜의 PDU. 데이터의 앞에 UDP 헤더를 붙임.

<br>

### 4. TCP 3-way-handshake

- **전송계층** : End point간 **신뢰성(순차적, 안정적)**있는 데이터 **전송(포트 번호에 해당하는 프로세스에 데이터를 전달)**을 담당하는 계층

  - 전송 계층의 중요성 
    - 데이터의 순차 전송을 원활하게 해줌
    - Flow (흐름 문제) 제어 - 송수신자 간의 데이터 처리 속도 차이 해결
    - Congestion (혼잡 문제) 제어 - 네트워크 혼잡 시, 데이터 처리 속도 해결

- **Flag bit**

  : TCP 헤더에는 TCP 연결 제어 및 데이터 관리를 하는 code bit(Flag bit)가 있음. (ACK, SYN, FIN)

  - ACK - 응답 (들린다고 대답함)
  - SYN - 연결 요청 (들리는지 물어봄)
  - FIN - 연결 끊기

<br>

#### TCP의 3-way-handshake (connection 연결)

1) (클라이언트->서버) SYN 비트를 1로 설정해 패킷 송신 : 너랑 연결하고 싶다.

2) (서버->클라이언트) SYN, ACK 비트를 1로 설정해 패킷 송신 : 알겠고, 나도 너랑 연결하고 싶다.

3) (클라이언트->서버) ACK 비트를 1로 설정해 패킷 송신 : 알겠다.

=> Established (연결 성립)

<br>

#### 4-way-handshake (connection 해제)

1) (클라이언트->서버) 데이터를 전부 송신한 클라이언트가 FIN 송신 : 나 연결 끊고 싶어.

2) (서버->클라이언트) 서버가 ACK 송신 : 알겠어.

2-1) (서버->클라이언트) 서버에서 남은 패킷 송신 (잠시 TIME OUT) : 남은 데이터 보내는 중...

3) (서버->클라이언트) 서버가 FIN 송신 : 다 보냈다.

4) (클라이언트->서버) 클라이언트가 ACK 송신 : ㅇㅋ

<br>

### 5. DNS Round Robin 방식

#### DNS (Domain Name System)

: 모든 **도메인 네임**과 해당하는 **IP주소**를 저장하는 데이터베이스.

도메인에 속해있는 컴퓨터들의 이름을 관리하고, **외부에 해당 컴퓨터의 IP주소를 알려주는 역할**을 한다. (웹 주소/URL을 입력하면, 도메인 네임서버(DNS)가 입력된 도메인 이름을 IP주소로 변환시켜 사용자를 해당 사이트에 연결시켜준다.)

사용자는 많은 사이트를 IP주소로 접속하는 것이 아니라, 도메인 네임으로 접속이 가능하게 되었다.

- 보통 네트워크 부하의 분산을 위해 master 네임서버(1차)와 slave 네임서버(2차)로 분리 운영
- IP->문자 (정방향) / 문자->IP (역방향)
- DNS서버는 **DNS 프로토콜**을 사용
  - 네트워크를 경유하여 **DNS 구현요소 간에 질의(query)/응답(response)을 수행**하기 위한 프로토콜

<br>

#### 네임서버 레코드

: DNS 상에서 도메인에 관한 설정을 하기 위해 사용되는 일련의 문자들.

네임서버는 1차부터 4차까지 무작위로 네임서버에 접근하여 사용자가 접속한 도메인의 레코드 정보를 찾게 된다. 네임서버에 요청된 레코드 정보에 따라, 사용자/서버에게 전달.

해당 DNS레코드의 성격에 따라, 이를 이용해 메일 서버 사용 설정 혹은 소유한 도메인의 소유권 확인 설정을 할 수 있다.

<br>

#### 로드 밸런싱

: 1대의 서버가 트래픽을 감당하기 어렵기 때문에, 웹서버의 부하(load)를 나눠가져 부담을 줄이는 방식. (분산식 웹서비스)

로드 밸런싱 방법

- **DNS Round Robin - 네임서버(DNS)의 도메인을 이용**
- L4를 이용한 로드밸런싱

<br>

#### DNS Round Robin

: **DNS를 이용해서 하나의 서비스에 여러 대의 서버를 분산**시키는 방법.

- 클라이언트의 웹서버 IP를 요청하는 쿼리를 받을 때마다, 2대의 웹서버를 번갈아가며 도메인을 알려주는 식.
- 동일한 이름으로 여러 레코드를 등록시키면, 질의할 때마다 다른 결과를 반환하며, 이 동작을 이용함으로써 여러 대의 서버에 처리를 분산시킬 수 있다.
- 윈도우 서버는 기본적으로 라운드 로빈이 활성화되어 있음.
- 장점
  - 비용적 부담이 줄어듦
  - 중간 장비 없이도 서비스 가능
- 문제점
  - 서버의 수만큼 공인 IP주소가 필요.
  - 1대의 서버에 장애가 발생했을 때, 원인을 찾기 힘듦. 장애 상황을 감지하지 못하므로, 서버에 이상이 있어도 이상이 있는 서버로 부하를 분산하게 됨.
  - 부하의 분산이 고르지 않음. (모바일 사이트에서 문제)
- 해결책) DNS 스케줄링 알고리즘
  - Weighted round robin - 웹서버에 가중치를 가미해, 처리능력이 좋은 서버에 높은 가중치를 부여하고, 빈번하게 선택되도록 한다.
  - Least connection - 접속 클라이언트 수가 가장 적은 서버가 선택되도록 한다.

<br>

### 6. 웹 통신의 큰 흐름

(크롬 주소창에 URL을 입력시키면 어떤 일이 일어나는가?)

#### in 브라우저

- 1) 브라우저 내부에서 결정된 규칙에 따라 URL에 입력된 값의 의미를 조사한다.
- 2) 조사된 의미에 따라 HTTP Request 메시지를 만든다.
- 3) 만들어진 메시지를 웹 서버로 전송한다.



#### in 프로토콜 스택, LAN 어댑터

- 1) 프로토콜 스택(OS에 내장된 NW제어용 SW)이 브라우저로부터 메시지를 받아, 이를 패킷 속에 저장한다.
- 2) 수신처 주소 등의 제어정보를 덧붙이고, 패킷을 LAN 어댑터에 넘긴다.
- 3) LAN 어댑터는 다음 Hop의 MAC주소를 붙인 프레임을 전기신호로 변환해, LAN 케이블에 송출시킨다.



#### in 허브, 스위치, 라우터

- 1) LAN 어댑터가 송신한 프레임은 스위칭 허브를 경유하여, 인터넷 접속용 라우터에 도착한다.
- 2) 라우터는 패킷을 프로바이더(통신사)에게 전달한다.
- 3) 인터넷으로 들어가게 된다.



#### in 액세스 회선, 프로바이더

- 1) 패킷은 인터넷 입구에 있는 액세스 회선(통신 회선)에 의해 POP(Point Of Presence, 통신사용 라우터)까지 운반된다.
- 2) POP를 거쳐 인터넷의 핵심부로 들어가게 된다.
- 3) 수많은 고속 라우터들 사이로 패킷이 목적지를 향해 흘러가게 된다.



#### in 방화벽, 캐시서버

- 1) 패킷을 인터넷 핵심부를 통과하여 웹 서버측의 LAN에 도착한다.

- 2) 기다리고 있던 방화벽이 도착한 패킷을 검사한다.

- 3)  패킷이 웹 서버까지 가야 하는지를 캐시서버가 판단. (굳이 서버까지 가지 않아도 되는 경우를 골라냄)

  액세스한 페이지의 데이터가 캐시서버에 있으면, 웹서버에 의뢰하지 않고 바로 읽어온다.



#### in 웹서버

- 1) 패킷이 물리적인 웹 서버에 도착하면, 웹 서버의 프로토콜 스택이 패킷을 추출, 메시지를 복원, 웹 서버 애플리케이션에 넘긴다.
- 2) 메시지를 받은 웹 서버 애플리케이션은 요청 메시지에 따른 데이터를 응답 메시지에 넣어 클라이언트로 회송.
- 3) 왔던 방식대로 응답 메시지가 클라에게 전달.

<br>

### 7. OSI 7 layer

: 통신이 일어나는 과정을 7개의 단계로 나눈 것. 통신을 7개의 단계별로 표준화하여, 그 효율성을 높이기 위해서 사용된다.

**-특징**

- 데이터의 흐름이 한눈에 보인다.
- 문제를 해결하기 편리하다.
- 층별 표준화를 통해 여러 회사 장비를 써도 이상없이 돌아감.



**-계층**

- Application Layer

- Presentation Layer

- Session Layer

- Transport Layer (레이어 4)

  : 흐름 제어, 에러 복구. 패킷을 재전송하거나, 흐름을 제어해 데이터가 정상적으로 전송될 수 있도록 한다. (TCP/UDP)

- Network Layer (레이어 3)

  : 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 것. (=라우팅) 경로를 선택하고, 주소를 정하며, 경로에 따라 패킷을 전달해주는 역할. (라우터)

- Data Link Layer (레이어2)

  : 정보의 오류/흐름을 관리, 안전한 정보의 전달을 수행할 수 있도록 도와줌(단위- 프레임). (스위치)

- Physical Layer (레이어 1)

  : 통신의 맨 아래 단계. 기계적 특성을 이용해 통신 케이블로 데이터를 전송(단위- 비트). (통신 케이블, 허브)