## Network

### 1. HTTP의 GET vs POST

- HTTP : 웹상에서 클라이언트와 서버 간에 요청/응답으로 데이터를 주고받을 수 있는 프로토콜.

  - HTTP 메소드 ) 서버가 요청을 수행하기 위해 해야할 행동을 표시하는 용도로, HTTP 요청에 포함되어 전송.

- **GET** : 서버로부터 **정보를 조회**하기 위해 설계된 메소드.

  - 필요한 데이터를 Body에 담지 않고, **헤더에 포함**시켜 요청.

    - 쿼리스트링(URL에`?이름1=값1&이름2=값2`)을 통해 전송. => 특정 페이지를 링크/북마크 가능.

  - URL에 데이터가 노출되어 보안에 취약. (ex. 패스워드가 노출되는 경우)

  - **데이터 양에 한계**가 있음.

  - 불필요한 요청을 제한하기 위해 브라우저에서 **요청이 캐시(저장)**될 수 있다. (js, css, image 와 같은 정적 컨텐츠는 데이터양이 크고, 변경될 일이 적어서 재요청을 보낼 필요가 없음) => 속도를 높이고, 즐겨찾기를 편리하게 해줌.

    *정적 컨텐츠 캐시 문제 때문에 컨텐츠를 변경해도 내용이 바뀌지 않을 수 있어, 이 때는 브라우저의 캐시를 지워주어야 한다.

  - Idempotent ) 동일한 요청을 여러 번 전송하더라도 동일한 응답이 돌아와야 함. 데이터/상태를 변경시키지 않아야 함.

    - 웹페이지 열어보기
    - 게시글 읽기

- **POST** : 데이터를 서버로 제출하여 리소스를 **생성/변경**하기 위한 메소드.

  - 데이터를 HTTP 메시지의 **Body에 담아** 전송. (URL에 변수노출X)

    => 요청 헤더의 content-Type에 요청 데이터의 타입을 표시해야 함.

  - Body는 길이의 제한이 없음. (**대용량 데이터 전송 가능**) / 최대 요청을 받는 시간 Time out이 존재해서 클라이언트가 페이지를 요청하고 기다리는 시간이 존재.

  - 민감한 데이터는 반드시 암호화해서 전송해야 함. (Body에 담겨있지만, 여러 툴로 확인 가능하므로)

  - **캐싱할 수 없음**.

  - non-Idempotent ) 서버에게 동일한 요청을 여러 번 전송해도 응답은 항상 다를 수 있음. 서버의 상태/데이터 변경시킴.

    - 게시글 작성
    - cf) 수정- PUT or PATCH / 삭제 - DELETE

*참고 - https://hongsii.github.io/2017/08/02/what-is-the-difference-get-and-post/





### 2. TCP 3-way-handshake

- **전송계층** : End point간 **신뢰성(순차적, 안정적)**있는 데이터 **전송(포트 번호에 해당하는 프로세스에 데이터를 전달)**을 담당하는 계층

  - 전송 계층의 중요성 
    - 데이터의 순차 전송을 원활하게 해줌
    - Flow (흐름 문제) 제어 - 송수신자 간의 데이터 처리 속도 차이 해결
    - Congestion (혼잡 문제) 제어 - 네트워크 혼잡 시, 데이터 처리 속도 해결

- **Flag bit**

  : TCP 헤더에는 TCP 연결 제어 및 데이터 관리를 하는 code bit(Flag bit)가 있음. (ACK, SYN, FIN)

  - ACK - 응답 (들린다고 대답함)
  - SYN - 연결 요청 (들리는지 물어봄)
  - FIN - 연결 끊기



#### TCP의 3-way-handshake (connection 연결)

1) (클라이언트->서버) SYN 비트를 1로 설정해 패킷 송신 : 너랑 연결하고 싶다.

2) (서버->클라이언트) SYN, ACK 비트를 1로 설정해 패킷 송신 : 알겠고, 나도 너랑 연결하고 싶다.

3) (클라이언트->서버) ACK 비트를 1로 설정해 패킷 송신 : 알겠다.

=> Established (연결 성립)



#### 4-way-handshake (connection 해제)

1) (클라이언트->서버) 데이터를 전부 송신한 클라이언트가 FIN 송신 : 나 연결 끊고 싶어.

2) (서버->클라이언트) 서버가 ACK 송신 : 알겠어.

2-1) (서버->클라이언트) 서버에서 남은 패킷 송신 (잠시 TIME OUT) : 남은 데이터 보내는 중...

3) (서버->클라이언트) 서버가 FIN 송신 : 다 보냈다.

4) (클라이언트->서버) 클라이언트가 ACK 송신 : ㅇㅋ





### 3. TCP vs UDP

#### TCP (Transmission Control Protocol)

- 신뢰성있는 데이터 통신을 가능하게 해주는 프로토콜
- 특징 ) connection 연결 (3 way-handshake) - 양방향 통신
- 데이터의 순차 전송을 보장
- Flow control (흐름 제어)
- Congestion control (혼잡 제어)
- Error detection (오류 감지)



*Segment : TCP 프로토콜의 PDU. 데이터를 cut해서 각각의 데이터 앞에 TCP 헤더를 붙임.



#### TCP의 문제점

- 전송의 신뢰성은 보장하지만, 매번 connection을 연결해 시간손실 발생 (3-way-handshake)
- 패킷을 조금만 손실해도 재전송



#### UDP (User Datagram Protocol)

- TCP보다 신뢰성이 떨어지지만, 전송속도가 일반적으로 빠른 프로토콜
- 순차 전송X, 흐름제어X, 혼잡제어X
- Connectionless (3-way-handshake X)
- Error detection
- 비교적 데이터의 신뢰성이 중요하지 않을 때 사용 (ex. 영상 스트리밍)



*User Datagram : UDP의 프로토콜의 PDU. 데이터의 앞에 UDP 헤더를 붙임.





### 4. HTTP vs HTTPS

#### HTTP (Hyper-text Transfer Protocol)

: 인터넷상의 커뮤니케이션에 사용되는 형식 중의 하나. (인터넷 규약)



#### HTTPS (Hyper-text Transfer Protocol Secure)

: HTTP 형식에 보안을 더한 형식.

- 웹사이트로 보내는 **정보를 제 3자가 보지 못하게** 한다. (HTTP형식. 즉, 텍스트 그대로 보내면 누구든 알아볼 수 있는 형식으로 보내진다.) HTTPS는 뒤죽박죽된 텍스트로 변경해서 실어보낸다.

  - 대칭키) 같은 키로 암호화/복호화

    : 키값을 넣고 암호화해서 보내면 전혀 다른 문자가 되어 보내짐. 받을 때는 해당 키값을 넣고, 알고리즘을 거꾸로 돌리면 풀 수 있다. (동일한 키를 가지고 있어야 함. 키가 노출되면 보안 문제 발생)

  - 비대칭키, 공개키) 서로 다른 한 쌍의 키

    : 두 개의 키는 무조건 한 쌍으로 움직임. (A키로 암호화하면, B키로 복호화. 또는 그 반대) 서버에서 두 키들 중 하나는 비밀로 보관(개인키)하고, 다른 하나를 대중에게 공개(공개키) 

- 접속한 사이트가 **신뢰할 수 있는 사이트인지 판별**해준다.

  - 서버에서 개인키로 암호화해서 웹사이트 정보를 보내면, 우리는 공개키로 복호화해서 볼 수 있다. (불법 사이트라면 공개키로 복호화 불가능!)
  - 브라우저들은 CA(개인키의 인증을 돕는 기업)의 목록들을 내장해서 공개키가 정품인지 알려줌



#### HTTP 구현과정

**1) 신뢰를 위한 탐색과정 (handshake)**

- 클라이언트는 **랜덤 데이터를 생성해 서버에 보냄**
- 이를 받은 서버도 **랜덤 데이터를 생성 + 해당 서버의 인증서**를 실어 보냄 (둘은 악수했다!!)

**2) 인증서가 정품인지 확인** (브라우저에 내장된 CA들의 정보를 통해)

- CA의 인증을 받은 인증서들은 해당 **CA의 개인키로 암호화**되어있음.

- 인증서가 **진짜라면, 브라우저에 저장되어 있는 CA의 공개키로 복호화할 수 있다!**

  - CA 목록에 그 인증서가 없다면, 브라우저 주소창엔 `not secure`이 뜸

- 성공적으로 **복호화된 인증서에는 서버의 공개키가 포함**되어있음

  

**3) 서버와 데이터 주고 받기** (다량의 데이터를 비대칭으로 하면 부담되기 때문에 **대칭/비대칭 방식으로 데이터를 주고 받음**)

- 클라이언트는 처음 악수할 때 주고받은 **랜덤 데이터 2개를 혼합해 임시 키를 생성**
- 이 임시 키는 **서버의 공개키로 암호화돼서 서버로 보내짐**
- 양쪽에서 일련의 과정을 거쳐 **동일한 대칭키가 만들어짐**

- **비대칭키를 사용하여 대칭키를 공유!** (제 3자가 대칭키를 알 수 없다)
- 이후 **대칭키를 사용해 데이터를 암호화** (대칭키는 서버와 클라이언트 둘만 갖고 있음~)

