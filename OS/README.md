## Ch1. 운영체제의 개요

**-운영체제란? **

![운영체제란](https://user-images.githubusercontent.com/58247800/100134631-d9aa7d80-2ecb-11eb-8a32-7ea2f0f80759.png)

: 컴퓨터 **하드웨어 바로 위에 설치**되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 **연결**하는 소프트웨어 계층.



**-운영체제의 목적**

: 컴퓨터 시스템의 **자원을 효율적으로 관리**. 

사용자간 형평성있게 자원을 분배하며, 주어진 자원으로 최대 성능을 내도록 한다.

- HW 자원 (프로세서/ 기억장치/ 입출력 장치 등)의 효율적 관리
- SW 자원 (프로세스/ 파일/ 메시지 등)을 관리
- 사용자 및 운영체제 자신의 보호



: 컴퓨터 시스템을 **편리**하게 사용할 수 있는 **환경 제공**. 

실행중인 프로그램들에게 짧은 시간씩 CPU를 번갈아 할당하고, 메모리 공간도 적절히 분배해준다.

- 동시 사용자/ 프로그램들이 각각 독자적 컴퓨터에서 실행되는 듯한 느낌을 제공
- HW를 직접 다루는 복잡한 부분을 OS가 대행



**-운영체제의 분류**

: 현재 쓰이는 운영체제의 종류를 나열하자면,

다중 작업(multi tasking) - 동시에 두 개 이상의 작업 처리

다중 사용자(multi user) - 여러 명의 컴퓨터 사용자에 의한 동시 접근을 허용

시분할(time sharing) - 여러 작업 수행 시, 일정 시간 단위로 분할해 처리 (**interactive**함)



**-운영체제의 예**

- 유닉스(UNIX) - 보통 대형 서버 컴퓨터를 위한 OS로, 코드의 대부분이 C언어로 작성되어 있다. 최소한의 커널 구조를 가지고 있으며, 복잡한 시스템에 맞게 확장이 용이하다. (프로그램 개발에 용이) 소스코드가 공개되어 있으며, 리눅스 등 다양한 버전이 나와있다.

- MS Windows - MS사의 다중 작업용 GUI기반 OS.



**-운영체제의 구조**

![운영체제의 구조](C:\Users\user\Desktop\Studying_CS\OS\img\운영체제의 구조.png)

- **CPU** - 누구에게 CPU를 줄지 정하는 **CPU 스케줄링**을 담당. (짧은 시간 간격으로 줬다 뺐었다를 반복)
- **메모리** - 한정된 메모리를 어떻게 쪼개어 쓸지? (**메모리 관리**)
- **디스크** - 디스크에 파일을 어떻게 보관하며, 헤드의 움직임을 최소화하고 빨리 실행할지? (**파일 관리**)
- **입출력 장치** - 각기 다른 입출력 장치와 컴퓨터 간에 어떻게 정보를 주고 받게 할지? (**입출력 관리**)

+) 프로세스 관리 - 프로세스의 생성/삭제, 자원 할당/반환, 프로세스간 협력

+) 그 외 - 보호 시스템/ 네트워킹/ 명령어 해석기



## Ch2. 시스템 구조와 프로그램 실행

운영체제를 본격적으로 시작하기에 앞서,

컴퓨터 시스템이 어떻게 동작하고, 프로그램들이 하드웨어 위에서 어떻게 돌아가는지 알아보자.



**-컴퓨터 시스템 구조**

: 쉽게 말해 **컴퓨터(CPU, 메모리)**가 호스트고, **입출력 장치**(하드디스크, 키보드/마우스, 프린터, 모니터 등)와 정보를 주고 받는다. 사이에는 DMA 컨트롤러와 타이머가 있다.

![컴퓨터시스템 구조](C:\Users\user\Desktop\Studying_CS\OS\img\컴퓨터시스템 구조.png)

- **CPU** - 매순간 메모리에서 기계어(instruction)를 읽어와 실행. 한 instruction이 끝나면, interrupt line 검사. 

  입출력 장치에 직접 접근하지 않고, 메모리에만 접근. 입출력 작업을 해야할 시에는 각 장치 제어기에게 시키고 다음 일을 함. (출력 값이 있어야 다음 일을 할 수 있을 때는 다음 프로그램으로 넘어감)

  굉장히 빠른 일꾼으로, 사용자 입장에서는 **interactive**하게 응답을 받게 된다.

  - **register** - 메모리보다 더 빠르게 정보를 저장하는 작은 공간.
  - **mode bit** - 지금 CPU를 사용하고 있는 주체가 OS인지 사용자 프로그램인지를 구분해줌
  - **interrupt line** - 입출력 관련 interrupt가 발생한 경우, 발생한 interrupt를 확인

- **메모리** - CPU의 작업 공간. 

- **입출력 장치** - 정보를 입력 받고, 내보내는 장치.

  - **장치 제어기**(device controller) - 각 입출력 장치를 전담하는 **작은 CPU**. 각 장치의 어떤 부분에서 어떤 내용을 읽어올지를 담당. (입출력 장치 속도가 CPU에 비해 매우 느리기 때문에 장치 제어기가 필요)
  - **local buffer** - 장치 제어기의 작업 공간. (메모리와 같은 역할)

- **타이머** - 특정 프로그램이 CPU를 **독점하지 못하도록** 막음. (OS가 작업을 CPU에 넘겨주기 전 **timer에 시간을 걸고**, 시간이 끝나면 **timer interrupt**를 발생, OS가 주도권을 다시 가져간다. ) 

- **DMA controller** - CPU의 중재 없이 데이터를 전송하고, 작업이 완료되면 interrupt를 걸어 CPU에게 알려줌.



예시를 들면,

CPU가 작업을 하던 중, 프로그램1이 키보드 입력정보가 필요 

-> (interrupt line을 세팅해 system call을 하고 OS가 주도권을 가짐) -> OS가 키보드 장치 제어기에게 해당 작업을 시킴 

-> 다음 프로그램2를 CPU가 진행 -> 입력값이 키보드 버퍼에 올라옴 -> 키보드 장치 제어기가 CPU에 interrupt를 걺 

-> CPU는 하던일을 멈추고, OS가 주도권을 가져가 입력값을 메모리에 copy 

-> 하던 일 프로그램2가 아직 할당시간이 끝나지 않았으므로 계속 진행됨. (프로그램1은 자기 차례를 기다림) 



구조별로 더 자세한 설명

**-Mode bit**

: 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기위한 **보호 장치**.

Mode bit를 통해 두 가지 모드의 operation을 지원한다.

- **1** - **사용자 모드** ) 사용자 프로그램을 수행
- **0 **- **커널모드** ) OS코드 수행

![모드비트](C:\Users\user\Desktop\Studying_CS\OS\img\모드비트.png)

interrupt가 발생하거나 예외 발생 시, HW가 mode bit를 0으로 바꿈.

사용자 프로그램에게 CPU를 넘기기 전에 mode bit를 1로 세팅.



**-Timer**

: CPU를 특정 프로그램이 독점하는 것으로부터 보호.

정해진 시간이 흐른 뒤, OS에게 제어권이 넘어가도록 **interrupt를 발생**시킨다.

타이머는 매 클릭 tick 마다 1씩 감소 -> 타이머 값이 0이 되면 'timer interrupt' 발생.



**-I/O Device Controller**(입출력 장치 제어기)

: 해당 I/O 장치 유형을 관리하는 일종의 **작은 CPU**.

제어 정보를 위해 control register, status register, local buffer를 가짐

I/O는 실제 device와 local buffer 사이에서 일어남 -> I/O가 끝나면 interrupt로 CPU에게 알림



**-입출력의 수행**

: 모든 입출력 명령은 특권명령이다.

사용자 프로그램이 I/O를 하려면,

​	1) **시스템콜(System call) **발생 - 사용자 프로그램이 interrupt line을 세팅해 OS에게 I/O를 요청 -> 모드가 1에서 0으로 변경됨

​	(_**시스템콜**_ - 사용자 프로그램이 OS서비스를 받기 위해 커널함수를 호출하는 것)

​	2) **trap**을 사용해 **interrupt vector**의 특정 위치로 이동

​	3) 제어권이 interrupt vector가 가리키는 **interrupt 서비스 루틴**으로 이동

​	4) 올바른 I/O 요청인지 확인 후, 수행

​	5) I/O 완료 시, 제어권을 시스템콜 다음 명령으로 옮김



**-인터럽트(interrupt)**

: 인터럽트는 포괄적인 의미로, 일반적 의미는 HW가 발생시킨 인터럽트이다.

시스템콜 / 예외적으로 프로그램이 오류를 범한 경우에는 SW가 인터럽트를 발생시키게 되는데, 이를 **Trap**이라고 한다. ('Trap을 이용해 인터럽트를 건다'고 함.)



+) **인터럽트 벡터** : **인터럽트 번호 - 주소 쌍**으로 해당 인터럽트의 처리루틴 **주소**를 갖고 있음.

**인터럽트 처리 루틴**(인터럽트 핸들러, **Interrupt Service Routine**): 해당 인터럽트를 처리하는 커널 함수로 **실제 해야할 일**이라고 생각하면 됨. 



=> 인터럽트 당한 시점의 레지스터와 program counter를 저장한 후, CPU의 제어를 인터럽트 처리 루틴에 넘긴다.

=> 현대 OS는 interrupt 구조에 의해 구동된다. (interrupt 걸릴 때만 OS가 CPU를 가짐)



**-동기식 입출력과 비동기식 입출력**

- **동기식 입출력**(Synchronous I/O) - I/O 요청 후, 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감. (다른 일을 수행하지 않고 기다림, 결과를 보고 다음 작업)
- **비동기식 입출력**(Asynchronous I/O) - I/O가 시작 된 후, 작업이 끝나기를 기다리지 않고, 제어가 사용자 프로그램에 즉시 넘어감. (입출력과 무관한 일로 넘어감)



**-DMA(Direct Memory Access)**

: 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용. CPU의 중재 없이, 장치 제어기가 장치의 buffer storage 내용을 메모리에 **block 단위**로 직접 전송.

(byte 단위가 아닌 block 단위로 인터럽트를 발생시킴)

---



**-서로 다른 I/O 명령어**

instruction의 두 가지 종류) 

- memory에 접근하는 instruction (ex. load store)

- I/O장치에 접근하는 instruction (by I/O를 수행하는 special instruction)

이렇게 보통은 memory와 device 주소를 각각 따로 두는 것이 일반적인데,

I/O device에 memory 주소를 매겨서 memory에 접근하는 instruction을 통해 I/O에 접근할 수도 있다. (**Memory Mapped I/O**)



**-저장장치 계층구조**

![저장장치 계층구조](C:\Users\user\Desktop\Studying_CS\OS\img\저장장치 계층구조.png)

- Primary storage ) CPU가 직접 접근해서 처리 가능 (Executable, byte 단위), 휘발성 매체

​       CPU - Register - Cache Memory(중간에서 속도 완충: **Caching** - 빠른 매체로 정보를 복사해서 올림, 재사용이 목적) - Main Memory (D-RAM)

- Secondary storage ) CPU가 직접 접근해서 처리하지 못함, 비휘발성 매체

​       Magnetic Disk - Optical Disk - Magnetic Tape 

=> 상위 단계일수록 속도가 빠른 매체를 사용 (비싸고 용량 적음)



**-프로그램의 실행** (프로그램이 컴퓨터에서 어떻게 실행되는가?)

![프로그램의 실행1](C:\Users\user\Desktop\Studying_CS\OS\img\프로그램의 실행1.png)

보통 프로그램은 파일 시스템(비휘발성 디스크)내에 실행파일 형태로 저장되어 있다. 이 실행파일을 실행시키면 **메모리**에 올라가 **프로세스**가 된다. (정확하게는 **가상 메모리**를 거쳐 물리적 메모리로 올려 실행시킴, 논리적 메모리 주소가 물리적 메모리 주소로 변환됨)

![프로그램의 실행](C:\Users\user\Desktop\Studying_CS\OS\img\프로그램의 실행.png)

1) 프로그램을 실행하면 그 프로그램의 **독자적인 메모리 주소공간**(code, data, stack 영역을 가진)이 생김.

- **code** - 기계어 코드를 담고 있음
- **data** - 변수 / 자료구조를 담고 있음
- **stack** - 데이터를 쌓거나 빼가는 용도

2) 당장 필요한 것만 물리적 메모리에 올린다. 그렇지 않은 부분은 디스크의 Swap area(메인 메모리의 연장공간, 전원 나가면 종료)에 내려놓는다.

부팅하면 커널영역은 메모리에 항상 상주해있지만, 사용자 프로그램 주소공간은 프로그램 종료 시 사라진다.



**-커널 주소 공간의 내용**

![커널 주소공간](C:\Users\user\Desktop\Studying_CS\OS\img\커널 주소공간.png)

- **code** (커널 코드) 

  - 시스템콜, 인터럽트 처리 코드
  - 자원 관리를 위한 코드
  - 편리한 서비스 제공을 위한 코드

- **data** (운영체제가 사용하는 자료구조들)

  - CPU, memory, disk와 같은 HW를 관리하기 위해 각각의 자료구조를 갖고 있음.
  - 프로세스들을 관리하기 위해 각 프로세스마다 자료구조(**PCB**)를 갖고 있음.

- **stack** (함수 호출 시 사용)

  : 사용자 프로그램마다 커널스택을 따로 갖고 있음.



**-사용자 프로그램이 사용하는 함수**

- **사용자 정의 함수 **

  : 자신의 프로그램에서 정의한 함수 (내가 직접 작성한 함수를 불러와 씀)

- **라이브러리 함수**

  : 자신의 프로그램에서 정의하지 않고 가져다 쓴 함수

=> 사용자 정의 함수와 라이브러리 함수 둘 다 자신의 프로그램 실행파일에 포함되어 있음. (사용자 프로세스의 code영역 내에서 점프하며 실행)

- **커널 함수**

  : 운영체제 프로그램의 함수. 내가 갖고있지 않고, 커널 함수를 호출해(virtual memory 내에서 점프할 수 없으므로, interrupt line을 세팅하고 **시스템 콜**) 씀.



**-프로그램의 실행** (프로그램 A 관점에서)



![프로그램A의 관점 실행](C:\Users\user\Desktop\Studying_CS\OS\img\프로그램A의 관점 실행.png)



## Ch3. 프로세스

**-프로세스의 개념**

: 프로세스는 **실행 중인 프로그램**이라는 뜻이다. 프로그램이 메인 메모리에 올라와 실행되고 있다면, (CPU가 이를 다룰 수 있는 상태) 프로세스라고 한다.



**-프로세스의 문맥**(context)

: 현재 어디서, 어떤 instruction을 수행했고, 어떤 상태인지를 나타내는 **프로세스의 모든 실행정보**.

CPU가 여러 프로세스를 왔다갔다(**동적상태**)하므로 이러한 문맥(어디까지 했으며, 어디서부터 다시 시작할지..)이 중요하다.



프로세스의 문맥을 나타내는 세 가지 요소를 알아보자.

- CPU 수행상태를 나타내는 **하드웨어 문맥** (현재 어떤 instruction을 수행하는지 보여준다)

  : program counter가 어딜 가리키는지? / 각종 register에 어떤 내용이 담겼는지?

- **프로세스의 주소공간** (memory 방면)

  : code, data, stack

- 프로세스 관련 **커널 자료구조** (커널상태 규명)

  : PCB, Kernel stack



**-프로세스의 상태 **(Process State)

: 프로세스는 상태가 변경되며 수행된다.

- **Running** - CPU를 잡고 instruction을 수행 중인 상태
- **Ready** - CPU를 기다리는 상태 (다른 조건은 모두 만족한 뒤)



- **Blocked** (wait, sleep) - CPU를 주어도 당장은 instruction을 수행할 수 없는 상태. 

  프로세스 자신이 요청한 이벤트(ex. I/O)가 만족되지 않아 이를 기다리는 중. (ex. 디스크에서 파일을 읽어와야 하는 경우)

- **Suspended** (stopped) - **외부적인 이유**로 프로세스의 수행이 정지된 상태. 프로세스는 통째로 디스크에 **swap out**된다. (ex. 사용자가 프로그램을 일시정지함 : break-key / 시스템이 여러 이유로 프로세스를 일시정지함)

***Blocked와 Suspended의 차이**

: Blocked는 자신이 요청한 event가 **완료되면 Ready**. 

Suspended는 **외부에서 resume** 해주어야 다시 active.



+ New - 프로세스가 생성 중인 상태
+ Terminated - 수행이 끝난 상태 (종료 전 정리...)



**-프로세스 상태도**

(그림)





