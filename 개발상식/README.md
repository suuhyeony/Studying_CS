## 개발 상식

### 1. 객체 지향 프로그래밍 (OOP)

: 인간 중심적 프로그래밍 패러다임이라고 할 수 있다. 즉, 현실 세계를 프로그래밍으로 옮겨와 프로그래밍하는 것을 말한다. **현실 세계의 사물들을 객체**라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 **특징들을 뽑아와 프로그래밍**하는 것이다. (추상화)

*객체 : 데이터와 기능이 클래스로 '캡슐화'된 컴퓨터 자원의 묶음



-특징

- **추상화**
  : 개별 기능의 목적에 맞는 이름을 임의로 붙일 수 있다. 프로그래머의 의도에 맞추어 가장 중요한 것들만을 뽑아서 복잡한 것들을 보다 단순한 모델로 변환하는 작업.
- **캡슐화** / 은닉성
  : 내부 구조는 private으로 감춰놓고, 외부에서 조작할 수 있는 명령어만 public으로 공개한다.
  바깥의 간섭으로 발생할 수 있는 오류들을 방지할 수 있으며, 남이 만든 객체들도 내부를 뜯어보지 않고 사용 가능하다. (남이 쓴 코드 이해하기 힘들수도)
- **상속**
  : 기존 부모 클래스(비교적 추상적)를 상속받아 새로운 자식 클래스(비교적 구체적)를 추가할 수 있다. 부모 생성자의 기능을 물려 받으면서, 새로운 기능을 추가.
- **다형성**
  : 여러 객체 타입에 같은 기능을 정의할 수 있는 능력. 상속을 받은 기능을 변경/확장하는 것. 부모 클래스에서 정의된 메소드의 작업이 자식 클래스에서 다른 것으로 override(대체)될 수 있다.

<br>

- 장점
  - 재사용성 높아짐 (생산성↑)
  - 신뢰성 확보
  - 컴파일 단계에서 에러를 잡아낼 수 있어 버그발생이 줄어듦
  - 객체 단위로 코드가 나눠져 작성 => 디버깅이 쉽고 유지보수에 용이
  - 객체와 매핑하기 수월 => 요구사항을 명확히 파악 가능
- 단점
  - 메시지 교환을 통한 객체간 정보 교환 => overhead 발생
  - 객체가 상태를 가짐 => 변수가 존재 => 객체가 예측할 수 없는 상태를 갖게 됨 => 앱 내부에서 버그를 발생시킴 => 함수형 패러다임 등장



### 2. RESTful API (REST란 형식의 API)

: WWW과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식으로, 자원을 정의하고 자원에 대한 주소를 지정하는 방법 전반에 대한 패턴. (데이터를 주고받는데 있어 개발자들 사이에 널리 쓰이는 형식. API에게 정보들을 요청하는 지정된 형식.)

즉, 어떤 URI(자원)에 어떤 메서드(행위)를 추가하느냐의 문제이다. 주소를 보고 누구나 알아볼 수 있도록 직관적이어야 한다.

(*REST : REpresentational State Transfer) (Resource Oriented Architecture)



- REST 6가지 원칙
  - Uniform Interface (폼이 정해져 있다)
  - Stateless (상태정보 저장X. API 서버는 들어오는 요청만 단순 처리)
  - Caching (HTTP가 가진 캐싱기능 적용 가능. Last-Modified/ E-Tag이용)
  - Client-Server (각 역할 구분 명확. 의존성 줄어듦)
  - Hierarchical system (계층형 구조. 다중계층으로 구성되어 암호화/보안 계층을 추가해 구조상의 유연성을 두고, 프록시/게이트웨이 같은 네트워크 기반 중간매체 사용 가능.)
  - Self-descriptiveness (자체 표현 구조. 메시지만 보고도 쉽게 이해 가능.)



- RESTful하게 API를 디자인 한다는 것은?
  - 1. 리소스와 행위를 명시적이고 직관적으로 분리한다.
       - 리소스(URI)는 명사로 표현되어야 한다.
       - 행위는 HTTP 메서드로 표현하고, GET(조회), POST(생성), PUT(전체수정), PATCH(일부수정), DELETE(삭제)를 분명한 목적으로 사용한다. (POST, PUT PATCH는 body라는 주머니가 있어 정보를 비교적 안전하게 감춰서 많이 실어보낼 수 있음)
  - 2. Message는 Header와 Body를 명확하게 분리해서 사용한다.
       - entity에 대한 내용은 body에 담는다.
       - 서버가 행동할 판단의 근거가 되는 컨트롤 정보인 API정보, 응답받고자 하는 MIME타입 등은 header에 담는다.
       - header와 body는 http나 json구조로 분리할 수 있다.
  - 3. API 버전을 관리한다.
       - API의 signature가 변경될 수도 있음에 유의하기.
       - 특정 API를 변경할 때는 반드시 하위호환성을 보장해야 한다.
  - 4. 서버와 클라이언트가 같은 방식을 사용해서 요청하도록 한다.
       - URI가 플랫폼 중립적이어야 한다. (같은 방식으로 보내야 함)



- 장점
  - Open API를 제공하기 쉬움
  - 멀티플랫폼 지원/연동 용이
  - 원하는 타입으로 데이터를 주고 받을 수 있음
  - 기존 웹 인프라(HTTP)를 그대로 사용 가능
- 단점
  - 사용가능한 메서드가 한정적
  - 분산환경에는 부적합
  - HTTP 통신 모델에 대해서만 지원



- 예시
  - GET ) https://(도메인)/classes/2/students/15
  - https://(도메인)/classes/2/students?sex=male
  - https://(도메인)/classes/2/students?page=2&count=10
  - POST ) https://(도메인)/classes/2/students
    - body : {"idx": 11, "name": "박수현", "sex": "female"}
  - PUT) https://(도메인)/classes/2/students/14 (변경대상. 새정보는 body에)



### 3. TDD (Test-Driven Development)

: 매우 짧은 개발 사이클의 반복에 의존하는 개발 프로세스. 먼저 새 기능에 대한 자동화된 테스트케이스를 작성하고, 해당 테스트를 통과하는 가장 간단한 코드를 작성. 테스트가 코드 작성을 주도하는 개발방식!



- 장점
  - 개발자가 코드를 작성하기 전에 보다 요구사항에 집중 가능
  - 새 기능과 기존 기능들이 잘 작동하는지 테스트 가능
  - 리팩토링 효율 향상, 코드 퀄리티 향상, 디버깅 시간 단축
- 단점
  - 코드량이 늘어남. 빠른 생산성이 요구된다면 비추
  - 진입장벽이 존재, 팀 전체가 익숙해져야 함
  - 예외 케이스 존재 (테스트 코드를 작성하는데 어려워 주객전도)



### 4. 함수형 프로그래밍

: 순수함수와 불변 데이터 타입을 사용하고, 공유상태와 부작용은 피한다. 명령형이 아닌 선언적으로 코드를 작성한다.

함수를 ''값''으로 보고 프로그래밍을 하는 것. 

함수의 동작에 의한 변수의 부수적인 값 변경을 원천 배제함으로써 오류를 방지한다. 문제의 소지가 있는 일은 하지 않는 코딩 방식. (부수효과 없이 안정적이고 예측가능한 프로그램을 짤 수 있다) 외부 변수를 사용하더라도, 그 본체에 접근해서 변경하는게 아니라 인자로 넣어 사본으로 복사해가서 작업을 하기 때문에 부작용은 일어나지 않음.

자기가 무슨 역할을 맡은지 모른채 그냥 들어오는걸 처리해서 내보낸다.

- 인풋과 아웃풋이 있다. 

  : 처리할 중간재료를 넘겨주면, 각자 맡은 작업을 해서 결과물을 반환한다.

- 외부 환경으로부터 철저히 독립적이다.

  : 다른 곳에 뭘 적어두지도, 참조하지도 않는다.자신에게 주어지는 것들로만 정해진 작업을 함.

- 같은 인풋에 있어서 언제나 동일한 아웃풋을 생산해낸다. (부작용으로부터 자유로움)

  : 외부 영향을 받지 않고, 다른 함수에게도 아무 영향을 주지 않는다. (순수함수) 

  *부작용/부수효과) 어떤 함수의 동작에 의해 프로그램 내 특정 상태가 변경되는 상황. 변경된 상태는 관련된 다른 동작들에게 영향을 미치게 된다.

  비함수형에서는 변수들이 변수로 작용하게 된다. (다른 외부인이 건드리거나, 작업의 타이밍이 엇갈릴 때..)



특징

- 1. immutable data : 한번 정해진 값은 바뀌지 않는다. state의 내부 상태를 바꾸게 아니라, 새로운 상태의 state를 만든다.
- 2. **first class citizen (일급 객체) **
     - 함수를 다른 함수의 인자로 넘길 수 있다
     - 함수 자체를 반환할 수 있다
     - 함수를 변수나 데이터에 할당 가능하다



- 특징
  - 1. 선언형 : 명령형과 반대되는 개념. 카카오=초콜릿(인풋만 같으면 절대 다른 요인에 의한 변수가 없음) *명령형에서는 변수만 a=1이다라고 하고, 함수는 변수를 처리하는 행위적 개념.
  - 2. 함수도 값이다 : 함수를 변수에 담아 호출가능 / 다른 함수에 콜백으로 넣어줌 / 함수를 인자로 넘길 수 있음
  - 3. 고계함수 : 인자로 다른 함수를 받아 결과값을 내보내는 함수.
  - 4. 커링 : 여러 인자를 받는 함수에 일부 인자만 넣어서, 나머지 인자를 받는 다른 함수를 만들어낼 수 있는 함수형 프로그래밍 기법. 인자들이 다 준비되지 않았을 때, 부분 적용된 상태의 함수를 만들어내서 마련해두거나 다른 함수에 인자로 넘겨줄 수 있음.
  - 5. 함수 컴비네이터 : 배열이나 리스트같은 컬렉션에서 자주 사용되는 기능으로, 컬렉션 내 요소들을 다양하고 연속적으로 처리할 수 있는 도구 (for문과 같은 반복문 혹은 변수를 지정하지 않아도 된다)
- 단점
  - 라인을 늘릴 때마다 신경쓸게 많아짐



- 반응형 프로그래밍?

  : 함수형 프로그래밍 언어의 도구들을 가지고 데이터 흐름을 composable하게 구현하는 것. (데이터의 흐름과 변화의 전달에 관한 프로그래밍 패러다임. 환경이 변화되면 이벤트를 받아 동작하는 과정) ReactiveX(**비동기 데이터 스트림을 처리**하는 API를 제공하는 라이브러리)는 다양한 종류의 언어들을 기반으로 반응형 프로그래밍을 할 수 있도록 도와줌.

  - 명령형 프로그래밍(C/Java)의 반대 개념. 

    : 즉, 내가 원하는 동작을 하나씩 구구절절 프로그래밍(for/while 등 반복문)을 지양한다. SQL과 같이 선언형을 지향한다.

  - 함수형 프로그래밍을 활용

    : 함수를 변수로도 활용하고 인자로 넘길 수 있다. (일급시민) 함수형 언어의 도구들을 자유자재로 활용할 수 있다.

  - 데이터의 흐름에서 시작



### 5. MVC(model-view-controller) 패턴

: 어플리케이션을 구성하는 패턴 중 하나이다. 프로그램의 시각적 부분과 동작/제어 처리부분을 분리하여 서로 영향을 주지 않고 프로그램을 변경할 수 있다.

- Model : 애플리케이션에서 사용되는 실제 데이터/로직을 처리하는 부분. DB에 연결하고 데이터를 추출/저장/삭제/업데이트/변환.
- View : 화면에 표시되는 부분(UI). 추출한 데이터나 텍스트/ 입력폼/ 사용자와의 상호작용을 위한 인터페이스를 표시.
- Controller : model과 view의 중개자로서, 사용자의 입력을 받고 처리. 각 요소들의 연결관계를 설정하고 **데이터와 시각적 부분의 연결**을 관리. url로부터 입력되는 정보로부터 어떤 데이터와 뷰를 연결할지를 제어.

<img src="C:\Users\multicampus\AppData\Roaming\Typora\typora-user-images\image-20210113175625338.png" alt="image-20210113175625338" style="zoom: 67%;" />

1. 사용자가 controller에 작업을 요청 (uses) -> 2. controller가 model을 호출해 데이터를 처리 (manipulates) -> 3. model이 데이터를 처리한 결과를 controller에게 전달 -> 4. controller는 model로부터 전달받은 결과를 view에 반영 (updates) -> 이 결과를 view를 통해 사용자가 보게 된다. (sees)

*MVC를 지원하는 자바스크립트 프레임워크는 Angular, Ember 등이 있다.



#### MVC1 vs MVC2

- 모델1 :  뷰와 로직을 모두 JSP페이지 하나에서 처리하는 구조. 과거에 가장 많이 사용되었던 아키텍쳐. 구조는 단순하지만, 뷰와 로직 코드가 섞여 복잡해짐. 백과 프론트가 혼재(분업 용이X)

- 모델2 : JSP(view) + 서블릿(controller) + 클래스/자바빈(model)로 나뉘어 브라우저 요청 처리. 분업 용이, 기능에 따른 분리로 유지보수 용이. 구조가 복잡해 습득이 어려움. 

  

### 6. Git

: VCS(버전 관리 시스템, 소프트웨어)  *Github은 이 sw를 제공하는 서비스

1)버전 관리, 2)협업, 3)오픈소스에 기여하기 위해 필요하다.



- 역할 : 소스 병합 (merge, rebase) / 리비전 관리 (reset, commit, branch) / 소스 릴리즈 (push) / 소스 태깅 (tag) / 변경사항 검토 (diff, log)

- 설정 : 1) 계정 정보 설정 `git config --global user.name "유저명"`

  ​		   2) git init (설치)  / 클론 받은 경우는 건너뜀

  ​		   3-1) 리모트 설정 `git remote add origin 저장소 주소`

  ​		   3-2) 클론 `git clone 저장소 주소` 

- 소스 기록 

  - 업로드(untracked / modified -> staged) : `git add .` / `git add 파일명` / `git add . -f`(숨김/삭제파일 이력까지)
  - 주소 확인 : `git remote show origin`

- 소스 커밋 (staged 상태 파일이 history로 기록, 적재)

  - 파일 추적 : `git status` / `git status -s`(간단히)
  - 커밋 : `git commit -m '메시지 내용' ` / `git commit -m '메시지 내용 수정' --amend` (덮어쓰기)

- 소스 업데이트 (상대방 커밋 파일 update, 동기화)

  - pull : `git pull origin master` (다운 + 병합)
  - fetch : `git fetch origin master` (다운만) -> 차이 확인 후 merge

- 소스 복원 (예전 버전으로 리셋)

  - `git reset HEAD^ --soft / --hard / --mixed`
  - `git reflog` (현재 위치 확인 후)  -> `git reset 현재위치`
  - `git reset HEAD~2` (2단계 전)
  - `git reset 특정 리비전 기록`

- 브랜치

  - 기본 : master 브랜치
  - 브랜치 생성 : `git branch 브랜치명`
  - master 기준으로 브랜치하면, master 소스가 새 브랜치에도 적용, 이후 다른 길을 감.
  - 생성된 브랜치로 접속 : `git chekout 브랜치명`
  - 브랜치를 원격 저장소에 등록 : `git push origin 브랜치명`
  - 브랜치 삭제 : `git branch -D 삭제할 브랜치명`-> 삭제 후, 원격 저장소에 반영하기!

- 소스 병합

  - merge (병합) : master에서 sub를 merge `git chekout -f master`->`git merge sub`
  - rebase (base 재설정)

- 충돌 / 해결 (같은 조상을 기준으로, 서로 다른 두 개의 branch가 같은 코드 변경 시)

  - 1) `git checkout master`
  - 2) `git pull origin master`
  - 3) `git chekout 충돌났던 브랜치`
  - 4) `git merge master`

- 변경사항 검토

  - diff
    - unstaged vs staged : `git diff`
    - staged vs commited : `git diff --staged`
  - log : 커밋 history 조회 `git log --oneline` / `git log --graph`